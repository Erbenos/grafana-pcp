{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"lodash\"","webpack:///./datasources/bpftrace/PCPContext.ts","webpack:///./datasources/bpftrace/poller.ts","webpack:///./datasources/bpftrace/datastore.ts","webpack:///./datasources/bpftrace/datasource.ts","webpack:///./datasources/bpftrace/query_ctrl.ts","webpack:///./datasources/bpftrace/module.ts","webpack:///external \"app/plugins/sdk\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_EXTERNAL_MODULE__0__","PCPContext","url","container","this","metricMetadataCache","missingMetrics","indomCache","createContext","contextUrl","datasourceRequest","contextResponse","_a","sent","context","data","external_lodash_default","a","isEmpty","fetchMetricMetadata","ensureContext","fn","__awaiter","_this","metricsResponse","metrics","findPmidForMetric","metric","pmidentry","find","pmid","includes","push","console","log","refreshIndoms","params","instances","indoms","reduce","cache","indom","instance","fetch","instanceNames","queryPmids","map","filter","length","pmids","join","_d","values","_i","instanceName","indomsForMetric","refreshed","_c","_b","store","POLL_INTERVAL_MS","poller_ContextPoller","ContextPoller","scriptMetricNames","requestedMetrics","registerScript","script","response","registerResponse","JSON","parse","ensurePolling","scriptMetricName","Date","getTime","poll","keys","cleanStaleMetrics","pollExpiry","pickBy","lastRequested","Poller","datastore","contextPollers","setInterval","doPollAll","contextPoller","then","ingest","cleanExpiredMetrics","bpftrace_PCPContext","DataStore","pollTimeEpochMs","timestamp","us","metricStore","query","targets","metrics_1","target","datapoints","datasource_PCPBPFtraceDatasource","PCPBPFtraceDatasource","instanceSettings","$q","backendSrv","templateSrv","variableSrv","q","withCredentials","headers","Content-Type","basicAuth","doRequest","poller","$inject","getAdhocFilters","adhocFilters","getVariables","hide","targetedMetrics","status","message","title","pcpContext","datasource_generator","options","variables","variable","variableValue","isEqual","allValue","slice","textValuePair","text","current","PCPBPFtraceDatasourceQueryCtrl","_super","$scope","$injector","__extends","refreshMetricData","templateUrl","__webpack_exports__","PCPBPFtraceConfigCtrl","PCPBPFtraceQueryOptionsCtrl","PCPBPFtraceAnnotationsQueryCtrl"],"mappings":"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","file":"./datasources/bpftrace/module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 128);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import _ from 'lodash';\n\ninterface MetricMetadata {\n  name: string,\n  pmid: number\n}\n\nexport default class PCPContext {\n\n  static datasourceRequest: (options: any) => any;\n  private context: string;\n  private metricMetadataCache: MetricMetadata[] = [];\n  private missingMetrics: string[] = [];\n  private indomCache: Record<string, Record<number, string>> = {}; // indomCache[metric][instance_id] = instance_name\n\n  constructor(readonly url: string, readonly container: string | null = null) {\n  }\n\n  async createContext() {\n    //console.log('** making request for context')\n    let contextUrl = `${this.url}/pmapi/context?hostspec=127.0.0.1&polltimeout=30`\n    if (this.container)\n      contextUrl += `&container=${this.container}`\n\n    const contextResponse = await PCPContext.datasourceRequest({ url: contextUrl })\n    //console.log('** contextResponse:', contextResponse)\n    this.context = contextResponse.data.context\n\n    if (this.container) {\n      //console.log('selecting container..')\n      const containerResponse = await PCPContext.datasourceRequest({\n        url: `${this.url}/pmapi/${this.context}/_store?name=pmcd.client.container&value=${this.container}`\n      })\n      //console.log('selected', containerResponse)\n    }\n\n    if (_.isEmpty(this.metricMetadataCache)) {\n      await this.fetchMetricMetadata();\n    }\n  }\n\n  async ensureContext(fn: () => any) {\n    if (!this.context) {\n      await this.createContext();\n    }\n\n    try {\n      return await fn();\n    } catch(err) {\n      await this.createContext();\n      return await fn();\n    }\n  }\n\n  async fetchMetricMetadata() {\n    //console.log('** making request for metrics')\n    await this.ensureContext(async () => {\n      const metricsResponse = await PCPContext.datasourceRequest({\n        url: `${this.url}/pmapi/${this.context}/_metric`\n      });\n      this.metricMetadataCache = metricsResponse.data.metrics;\n    });\n  }\n\n  findPmidForMetric(metric: string) {\n    const pmidentry = this.metricMetadataCache.find(p => p.name === metric)\n    if (pmidentry) {\n        return pmidentry.pmid\n    } else { // no pmid found\n        if (!this.missingMetrics.includes(metric)) {\n            this.missingMetrics.push(metric)\n            console.log(`Cannot find pmid for ${metric}. Is this PMDA enabled?`)\n        }\n        return null\n    }\n  }\n\n  async refreshIndoms(metric: string) {\n    const indoms = await this.ensureContext(async () => {\n      const response = await PCPContext.datasourceRequest({\n        url: `${this.url}/pmapi/${this.context}/_indom`,\n        params: {name: metric}\n      });\n      return response.data.instances;\n    });\n\n    // convert [{instance: X, name: Y}] to {instance: name}\n    this.indomCache[metric] = indoms.reduce((cache: any, indom: any) => {\n      cache[indom.instance] = indom.name;\n      return cache;\n    }, {});\n    return this.indomCache[metric];\n  }\n\n  async fetch(metrics: string[], instanceNames: boolean = false) {\n    // extract pmid for metric name\n    const queryPmids = metrics\n      .map((metric: string) => this.findPmidForMetric(metric))\n      .filter((metric: number|null) => metric) // filter out nulls from findPmidForMetric\n\n    if (!queryPmids.length)\n      return []\n\n    // by now we have a context, the pmids to fetch, so lets do it\n    \n    const data = await this.ensureContext(async () => {\n      const response = await PCPContext.datasourceRequest({\n        url: `${this.url}/pmapi/${this.context}/_fetch`,\n        params: {pmids: queryPmids.join(',')}\n      });\n      return response.data;\n    });\n\n    if (instanceNames) {\n      // add instance names to instances\n      for (const metric of data.values) {\n        if (metric.instances.length == 0) {\n          continue;\n        } else if (metric.instances[0].instance === -1) { // this metric has no instances (single value)\n          metric.instances[0].instanceName = null;\n          continue;\n        }\n\n        let indomsForMetric = this.indomCache[metric.name];\n        if (!indomsForMetric)\n          indomsForMetric = await this.refreshIndoms(metric.name);\n          \n        let refreshed = false;\n        for(const instance of metric.instances) {\n          instance.instanceName = indomsForMetric[instance.instance];\n          if (!instance.instanceName && !refreshed) {\n            // refresh instances at max once per metric\n            indomsForMetric = await this.refreshIndoms(metric.name);\n            instance.instanceName = indomsForMetric[instance.instance];\n            refreshed = true;\n          }\n        }\n      }\n    }\n\n    return data;\n  }\n\n  async store(metric: string, value: string) {\n    return await this.ensureContext(() => {\n      return PCPContext.datasourceRequest({\n        url: `${this.url}/pmapi/${this.context}/_store`,\n        params: {name: metric, value: value}\n      })\n    });\n  }\n}\n","import _ from 'lodash';\nimport PCPContext from \"./PCPContext\";\nimport DataStore from './datastore';\n\n// poll metric sources every X ms\nconst POLL_INTERVAL_MS = 1000\n// we will keep polling a metric for up to X ms after it was last requested\nconst KEEP_POLLING_MS = 20000\n// age out time\nconst OLDEST_DATA_MS = 5*60*1000\n\nclass ContextPoller {\n    readonly scriptMetricNames: Record<string, string> = {}; // {bpftrace_script: pcp_metric_name}\n    private requestedMetrics: Record<string, number> = {}; // {metric: lastRequested}\n\n    constructor(readonly context: PCPContext) {\n    }\n\n    async registerScript(script: string) {\n        await this.context.store(\"bpftrace.control.register\", script);\n        const response = await this.context.fetch([\"bpftrace.control.register\"]);\n        const registerResponse = JSON.parse(response.values[0].instances[0].value);\n        console.log(\"registered\", script, \"as\", registerResponse.metrics[0]);\n        return registerResponse.metrics[0];\n    }\n\n    async ensurePolling(script: string) {\n        let scriptMetricName = this.scriptMetricNames[script];\n        if (!scriptMetricName) {\n            scriptMetricName = await this.registerScript(script);\n            this.scriptMetricNames[script] = scriptMetricName;\n        }\n        this.requestedMetrics[scriptMetricName] = new Date().getTime()\n        return scriptMetricName;\n    }\n\n    async poll() {\n        return await this.context.fetch(Object.keys(this.requestedMetrics), true);\n    }\n\n    cleanStaleMetrics() {\n        // clean up any not required metrics before we poll\n        const pollExpiry = new Date().getTime() - KEEP_POLLING_MS\n        this.requestedMetrics = _.pickBy(this.requestedMetrics, lastRequested => lastRequested > pollExpiry)\n    }\n}\n\nexport default class Poller {\n\n    readonly contextPollers: Record<string, ContextPoller> = {};\n\n    constructor(readonly datastore: DataStore) {\n        setInterval(this.doPollAll.bind(this), POLL_INTERVAL_MS)\n    }\n\n    doPollAll() {\n        for(const contextPoller of Object.values(this.contextPollers)) {\n            contextPoller.cleanStaleMetrics();\n            contextPoller.poll().then((data) => this.datastore.ingest(contextPoller.context.url, data));\n        }\n\n        this.datastore.cleanExpiredMetrics();\n    }\n\n    async ensurePolling(url: string, script: string) {\n        let contextPoller = this.contextPollers[url];\n        if (!contextPoller) {\n            contextPoller = new ContextPoller(new PCPContext(url));\n            this.contextPollers[url] = contextPoller;\n        }\n        return await contextPoller.ensurePolling(script);\n    }\n}","export default class DataStore {\n    private store: Record<string, Record<string, Record<string, [number,number][]>>> = {}; // store[url][metric][instance] = [val,ts]\n\n    constructor() {\n    }\n\n    ingest(url: string, data: any) {\n        if (!(url in this.store)) {\n            this.store[url] = {};\n        }\n\n        const pollTimeEpochMs = data.timestamp.s * 1000 + data.timestamp.us / 1000;\n        for(const metric of data.values) {\n            let metricStore = this.store[url][metric.name];\n            if (!metricStore) {\n                metricStore = this.store[url][metric.name] = {};\n            }\n\n            for (const instance of metric.instances) {\n                if (!(instance.instanceName in metricStore))\n                    metricStore[instance.instanceName] = [];\n\n                metricStore[instance.instanceName].push([instance.value, pollTimeEpochMs])\n            }\n        }\n    }\n\n    query(url: string, metrics: string[]) {\n        if (!(url in this.store))\n            return [];\n\n        let targets = [] as any;\n        for(const metric of metrics) {\n            if (!(metric in this.store[url]))\n                continue;\n\n            for(const instance in this.store[url][metric]) {\n                targets.push({\n                    // for metrics without instance domains, show metric name\n                    target: instance === \"null\" ? metric : instance,\n                    datapoints: this.store[url][metric][instance]\n                });\n            }\n        }\n        return targets;\n    }\n\n    cleanExpiredMetrics() {\n    }\n}\n","///<reference path=\"../../../node_modules/grafana-sdk-mocks/app/headers/common.d.ts\" />\nimport _ from 'lodash';\nimport PCPContext from './PCPContext';\nimport Poller from './poller';\nimport DataStore from './datastore';\n\nexport class PCPBPFtraceDatasource {\n\n  name: string;\n  url: string;\n  q: any;\n  backendSrv: any;\n  templateSrv: any;\n  variableSrv: any;\n  withCredentials: boolean;\n  headers: any;\n  datastore: DataStore;\n  poller: Poller;\n\n  /** @ngInject **/\n  constructor(instanceSettings, $q, backendSrv, templateSrv, variableSrv) {\n    this.name = instanceSettings.name;\n    this.url = instanceSettings.url;\n    this.q = $q;\n    this.backendSrv = backendSrv;\n    this.templateSrv = templateSrv;\n    this.variableSrv = variableSrv;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.headers = { 'Content-Type': 'application/json' };\n    if (typeof instanceSettings.basicAuth === 'string' && instanceSettings.basicAuth.length > 0) {\n      this.headers['Authorization'] = instanceSettings.basicAuth;\n    }\n\n    this.datastore = new DataStore();\n    PCPContext.datasourceRequest = this.doRequest.bind(this);\n    this.poller = new Poller(this.datastore);\n  }\n\n  async query(options: any) {\n    const query = options;\n    if (query.targets.length == 0) {\n      return { data: [] };\n    }\n\n    if (this.templateSrv.getAdhocFilters) {\n      query.adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    } else {\n      query.adhocFilters = [];\n    }\n\n    const vars = this.getVariables();\n    // TODO: url of target => url variable of dashboard => url setting of datasource\n    let targetedMetrics : string[] = [];\n    for(let target of query.targets) {\n      if (!target.hide) {\n        targetedMetrics.push(await this.poller.ensurePolling(this.url, target.script));\n      }\n    }\n \n    return { data: this.datastore.query(this.url, targetedMetrics) };\n  }\n\n  async testDatasource() {\n    let pcpContext = new PCPContext(this.url, null);\n    try {  \n      await pcpContext.createContext();\n      return { status: 'success', message: \"Data source is working\", title: \"Success\" };\n    }\n    catch(error) {\n      return {\n        status: 'error',\n        message: `Cannot connect to ${pcpContext.url}`,\n        title: 'Error',\n      };\n    }\n  }\n\n  async metricFindQuery(query) {\n    return [];\n  }\n\n  async doRequest(options: any) {\n    options.withCredentials = this.withCredentials;\n    options.headers = this.headers;\n\n    return await this.backendSrv.datasourceRequest(options);\n  }\n\n  getVariables(): any {\n    const variables = {};\n    if (!this.variableSrv.variables) {\n        // variables are not defined on the datasource settings page\n        return {};\n    }\n\n    for (let variable of this.variableSrv.variables) {\n      let variableValue = variable.current.value;\n      if (variableValue === '$__all' || _.isEqual(variableValue, ['$__all'])) {\n        if (variable.allValue === null) {\n          variableValue = variable.options.slice(1).map(textValuePair => textValuePair.value);\n        } else {\n          variableValue = variable.allValue;\n        }\n      }\n\n      variables[variable.name] = {\n        text: variable.current.text,\n        value: variableValue,\n      };\n    }\n\n    return variables;\n  }\n}\n","import { QueryCtrl } from 'grafana/app/plugins/sdk';\n\nexport class PCPBPFtraceDatasourceQueryCtrl extends QueryCtrl {\n  static templateUrl = 'datasources/bpftrace/partials/query.editor.html';\n\n  /** @ngInject **/\n  constructor($scope, $injector) {\n    super($scope, $injector);\n\n    this.target.script = this.target.script || \"\";\n  }\n\n  refreshMetricData() {\n    this.panelCtrl.refresh(); // Asks the panel to refresh data.\n  }\n}\n","import { PCPBPFtraceDatasource } from './datasource';\nimport { PCPBPFtraceDatasourceQueryCtrl } from './query_ctrl';\n\nclass PCPBPFtraceConfigCtrl {\n  static templateUrl = 'datasources/bpftrace/partials/config.html';\n}\n\nclass PCPBPFtraceQueryOptionsCtrl {\n  static templateUrl = 'datasources/bpftrace/partials/query.options.html';\n}\n\nclass PCPBPFtraceAnnotationsQueryCtrl {\n  static templateUrl = 'datasources/bpftrace/partials/annotations.editor.html';\n}\n\nexport {\n  PCPBPFtraceDatasource as Datasource,\n  PCPBPFtraceDatasourceQueryCtrl as QueryCtrl,\n  PCPBPFtraceConfigCtrl as ConfigCtrl,\n  PCPBPFtraceQueryOptionsCtrl as QueryOptionsCtrl,\n  PCPBPFtraceAnnotationsQueryCtrl as AnnotationsQueryCtrl,\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;"],"sourceRoot":""}